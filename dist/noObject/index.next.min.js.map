{"version":3,"file":"index.next.min.js","sources":["../../src/converters/A1-Row.ts","../../src/converters/Col-A1.ts","../../src/converters/Row-A1.ts","../../src/validation/isValidA1.ts","../../src/validation/isValidNumber.ts","../../src/validation/A1Error.ts","../../src/index.noObject.ts","../../src/converters/A1-Col-1.ts","../../src/converters/A1-Col-2.ts"],"sourcesContent":["/**\r\n *\t@fileOverview Converts row string to number\r\n *\t@param {string} row\r\n *\r\n *\t@return {number}\r\n */\r\nexport default function(row: string): number\r\n{\r\n\treturn parseInt(row, 10);\r\n}","/**\r\n *\t@fileOverview Converts column number to letter\r\n *\t@author AdamL\r\n *\t@see https://stackoverflow.com/questions/21229180/convert-column-index-into-corresponding-column-letter\r\n *\t@param {number} col\r\n *\r\n *\t@return {string}\r\n */\r\nexport default function(col: number): string\r\n{\r\n\tlet letter = '',\r\n\t\ttemp;\r\n\twhile(col > 0)\r\n\t{\r\n\t\ttemp \t= (col - 1) % 26;\r\n\t\tletter \t= String.fromCharCode(temp + 65) + letter;\r\n\t\tcol \t= (col - temp - 1) / 26;\r\n\t}\r\n\treturn letter;\r\n}","/**\r\n *\t@fileOverview Converts row number to string\r\n *\t@param {number} row\r\n *\r\n *\t@return {string}\r\n */\r\nexport default function(row: number): string\r\n{\r\n\treturn row.toString();\r\n}","/**\r\n *\t@fileOverview Checks validation\r\n *\t@param {string} a1\r\n *\r\n *\t@return {boolean}\r\n */\r\nexport default function(a1: string): boolean\r\n{\r\n\treturn /^[A-Z]+\\d+(:[A-Z]+\\d+)?$/i.test(a1);\r\n}","/**\r\n *\t@fileOverview Checks number validation\r\n *\t@param {T} n\r\n *\t@param {boolean} [strict = true]\r\n *\r\n *\t@return {boolean}\r\n */\r\nexport default function<T>(n: T, strict: boolean = true): boolean\r\n{\r\n\tlet isNumber = typeof n === 'number' && Number.isInteger(n);\r\n\treturn strict ? (isNumber && +n > 0) : isNumber;\r\n}","/**\r\n *\t@fileOverview A1 notation errors\r\n */\r\nexport default class A1Error<T> extends Error\r\n{\r\n\tconstructor(a1: string)\r\n\tconstructor(col: number)\r\n\tconstructor(row: number)\r\n\tconstructor(unknown?: T)\r\n\tconstructor(something?: string | number | T)\r\n\t{\r\n\t\tlet str = JSON.stringify(something);\r\n\t\tsuper(str);\r\n\t\tthis.name \t\t= 'A1Error';\r\n\t\tthis.message \t= str;\r\n\t}\r\n\r\n\twasString(): A1Error<T>\r\n\t{\r\n\t\tthis.message = `Invalid A1 notation: ${this.message}`;\r\n\t\treturn this;\r\n\t}\r\n\r\n\twasNumber(): A1Error<T>\r\n\t{\r\n\t\tthis.message = `Invalid A1 number(s): ${this.message}`;\r\n\t\treturn this;\r\n\t}\r\n\r\n\twasUnknown(): A1Error<T>\r\n\t{\r\n\t\tthis.message = `Invalid A1 argument(s): ${this.message}`;\r\n\t\treturn this;\r\n\t}\r\n}","/**\r\n *\t@fileOverview Math operations and converting in A1 notation\r\n *\tSupports A1 notation like \"A1\" and \"A1:B2\"\r\n *\t@author FLighter\r\n */\r\n\r\nimport A1Col1 \t\t\tfrom './converters/A1-Col-1';// converter 1\r\nimport A1Col2 \t\t\tfrom './converters/A1-Col-2';// converter 2\r\nimport A1Row \t\t\tfrom './converters/A1-Row';\r\nimport ColA1 \t\t\tfrom './converters/Col-A1';\r\nimport RowA1 \t\t\tfrom './converters/Row-A1';\r\nimport isValidA1 \t\tfrom './validation/isValidA1';\r\nimport isValidNumber \tfrom './validation/isValidNumber';\r\nimport A1Error \t\t\tfrom './validation/A1Error';\r\n\r\nclass A1\r\n{\r\n\t// Regular expression for parsing\r\n\tprivate static _reg:RegExp = /^([A-Z]+)(\\d+)(?::([A-Z]+)(\\d+))?$/;\r\n\t/**\r\n\t *\tExample: A1:B2\r\n\t */\r\n\tprivate _colStart: \tnumber \t= 0;// A -> 1\r\n\tprivate _rowStart: \tnumber \t= 0;// 1 -> 1\r\n\tprivate _colEnd: \tnumber \t= 0;// B -> 2\r\n\tprivate _rowEnd: \tnumber \t= 0;// 2 -> 2\r\n\tprivate _converter: 1 | 2 \t= 1;// converter 1 | 2\r\n\r\n\t/**\r\n\t *\tParses A1 notation\r\n\t *\t@param {string} a1\r\n\t *\t@param {1 | 2}  converter\r\n\t *\r\n\t *\t@return {object} {cs: number, rs: number, ce: number, re: number}\r\n\t */\r\n\tprivate static _parse(a1: string, converter: 1 | 2): {cs: number, rs: number, ce: number, re: number}\r\n\t{\r\n\t\tlet [\r\n\t\t\t\t,\r\n\t\t\t\tcs,// col start // A\r\n\t\t\t\trs,// row start // 1\r\n\t\t\t\tce,// col end \t// B\r\n\t\t\t\tre,// row end \t// 2\r\n\t\t\t] = a1.toUpperCase().match(this._reg);\r\n\t\tce = ce || cs;\r\n\t\tre = re || rs;\r\n\t\tlet colStart \t= this._A1Col(cs, converter),\r\n\t\t\tcolEnd \t\t= this._A1Col(ce, converter),\r\n\t\t\trowStart \t= A1Row(rs),\r\n\t\t\trowEnd \t\t= A1Row(re);\r\n\t\t// For non-standard A1\r\n\t\treturn {\r\n\t\t\tcs: colEnd > colStart ? colStart : colEnd,\r\n\t\t\trs: rowEnd > rowStart ? rowStart : rowEnd,\r\n\t\t\tce: colEnd > colStart ? colEnd \t : colStart,\r\n\t\t\tre: rowEnd > rowStart ? rowEnd \t : rowStart,\r\n\t\t}\r\n\t}\r\n\t/**\r\n\t *\tConverts column letter to number using converter 1 or 2\r\n\t *\t@param {string} a1\r\n\t *\t@param {1 | 2} converter\r\n\t *\r\n\t *\t@return {number}\r\n\t */\r\n\tprivate static _A1Col(a1: string, converter: 1 | 2): number\r\n\t{\r\n\t\treturn converter === 1 ? A1Col1(a1) : A1Col2(a1);\r\n\t}\r\n\r\n\t/******************\r\n\t *\tSTATIC METHODS\r\n\t ******************/\r\n\t/**\r\n\t *\tChecks A1 notation\r\n\t *\t@param {string} a1\r\n\t *\r\n\t *\t@return {boolean}\r\n\t */\r\n\tstatic isValid(a1: string): boolean\r\n\t{\r\n\t\treturn isValidA1(a1);\r\n\t}\r\n\t/**\r\n\t *\tConverts the first column letter from A1 to number\r\n\t *\t@param {string} a1\r\n\t *\t@param {1 | 2} [converter = 1]\r\n\t *\r\n\t *\t@return {number}\r\n\t */\r\n\tstatic getCol(a1: string, converter: 1 | 2 = 1): number\r\n\t{\r\n\t\tif(!isValidA1(a1))\r\n\t\t\tthrow new A1Error(a1).wasString();\r\n\t\treturn this._parse(a1, converter).cs;\r\n\t}\r\n\t/**\r\n\t *\tConverts the last column letter from A1 to number\r\n\t *\t@param {string} a1\r\n\t *\t@param {1 | 2} [converter = 1]\r\n\t *\r\n\t *\t@return {number}\r\n\t */\r\n\tstatic getLastCol(a1: string, converter: 1 | 2 = 1): number\r\n\t{\r\n\t\tif(!isValidA1(a1))\r\n\t\t\tthrow new A1Error(a1).wasString();\r\n\t\treturn this._parse(a1, converter).ce;\r\n\t}\r\n\t/**\r\n\t *\tConverts number to column letter in A1\r\n\t *\t@param {number} col\r\n\t *\r\n\t *\t@return {string}\r\n\t */\r\n\tstatic toCol(col: number): string\r\n\t{\r\n\t\tif(!isValidNumber(col))\r\n\t\t\tthrow new A1Error(col).wasNumber();\r\n\t\treturn ColA1(col);\r\n\t}\r\n\t/**\r\n\t *\tConverts the first row string to number\r\n\t *\t@param {string} a1\r\n\t *\r\n\t *\t@return {number}\r\n\t */\r\n\tstatic getRow(a1: string): number\r\n\t{\r\n\t\tif(!isValidA1(a1))\r\n\t\t\tthrow new A1Error(a1).wasString();\r\n\t\treturn this._parse(a1, 1).rs;\r\n\t}\r\n\t/**\r\n\t *\tConverts the last row string to number\r\n\t *\t@param {string} a1\r\n\t *\r\n\t *\t@return {number}\r\n\t */\r\n\tstatic getLastRow(a1: string): number\r\n\t{\r\n\t\tif(!isValidA1(a1))\r\n\t\t\tthrow new A1Error(a1).wasString();\r\n\t\treturn this._parse(a1, 1).re;\r\n\t}\r\n\t/**\r\n\t *\tConverts number to row string in A1\r\n\t *\t@param {number} row\r\n\t *\r\n\t *\t@return {string}\r\n\t */\r\n\tstatic toRow(row: number): string\r\n\t{\r\n\t\tif(!isValidNumber(row))\r\n\t\t\tthrow new A1Error(row).wasNumber();\r\n\t\treturn RowA1(row);\r\n\t}\r\n\t/**\r\n\t *\t@param {string} a1\r\n\t *\t@param {1 | 2} [converter = 1]\r\n\t *\r\n\t *\t@return {number} columns count\r\n\t */\r\n\tstatic getWidth(a1: string, converter: 1 | 2 = 1): number\r\n\t{\r\n\t\tif(!isValidA1(a1))\r\n\t\t\tthrow new A1Error(a1).wasString();\r\n\t\tlet {ce, cs} = this._parse(a1, converter);\r\n\t\treturn ce - cs + 1;\r\n\t}\r\n\t/**\r\n\t *\t@param {string} a1\r\n\t *\r\n\t *\t@return {number} rows count\r\n\t */\r\n\tstatic getHeight(a1: string): number\r\n\t{\r\n\t\tif(!isValidA1(a1))\r\n\t\t\tthrow new A1Error(a1).wasString();\r\n\t\tlet {re, rs} = this._parse(a1, 1);\r\n\t\treturn re - rs + 1;\r\n\t}\r\n\r\n\t/***************\r\n\t *\tCONSTRUCTOR\r\n\t ***************/\r\n\t/**\r\n\t *\tIt handles cases:\r\n\t *\tconstructor(col: number, row: number)\r\n\t *\tconstructor(col: number, row: number, nRows: number)\r\n\t *\tconstructor(col: number, row: number, nRows: number, nCols: number)\r\n\t *\t@param {number[]} args\r\n\t */\r\n\tprivate _initNumber(...args: number[]): void\r\n\t{\r\n\t\tlet [col, row, nRows, nCols] = args;\r\n\t\tnRows = nRows || 1;\r\n\t\tnCols = nCols || 1;\r\n\t\tlet all = [col, row, nRows, nCols];\r\n\t\tif(!all.every(n => isValidNumber(n)))\r\n\t\t\tthrow new A1Error(all.join(', ')).wasNumber();\r\n\t\tthis._colStart \t= col;\t\t\t\t// the first col\r\n\t\tthis._rowStart \t= row;\t\t\t\t// the first row\r\n\t\tthis._colEnd \t= col + nCols - 1;\t// how many cols in total (cols length)\r\n\t\tthis._rowEnd \t= row + nRows - 1;\t// how many rows in total (rows length)\r\n\t}\r\n\t/**\r\n\t *\tIt handles cases:\r\n\t *\tconstructor(range: string)\r\n\t *\tconstructor(rangeStart: string, rangeEnd: string)\r\n\t *\t@param {string[]} args\r\n\t */\r\n\tprivate _initString(...args: string[]): void\r\n\t{\r\n\t\tlet [rangeStart, rangeEnd] = args,\r\n\t\t\trange = rangeEnd\r\n\t\t\t\t\t\t? `${rangeStart}:${rangeEnd}`// rangeStart: string, rangeEnd: string\r\n\t\t\t\t\t\t: rangeStart;\t\t\t\t // range: string\r\n\t\tif(!isValidA1(range))\r\n\t\t\tthrow new A1Error(range).wasString();\r\n\t\tlet {cs, rs, ce, re} = A1._parse(range, this._converter);\r\n\t\tthis._colStart \t= cs;\r\n\t\tthis._rowStart \t= rs;\r\n\t\tthis._colEnd \t= ce;\r\n\t\tthis._rowEnd \t= re;\r\n\t}\r\n\t/**\r\n\t *\tConstructor\r\n\t */\r\n\tconstructor(range: string)\r\n\tconstructor(rangeStart: string, rangeEnd: string)\r\n\tconstructor(col: number, row: number)\r\n\tconstructor(col: number, row: number, nRows: number)\r\n\tconstructor(col: number, row: number, nRows: number, nCols: number)\r\n\tconstructor(something: string | number, something2?: string | number, nRows?: number, nCols?: number)\r\n\t{\r\n\t\t// No arguments\r\n\t\tif(!arguments.length)\r\n\t\t\tthrow new A1Error().wasUnknown();\r\n\t\tlet type = typeof something;\r\n\t\t// Number\r\n\t\tif(type === 'number')\t\tthis._initNumber.apply(this, arguments);\r\n\t\t// String\r\n\t\telse if(type === 'string')\tthis._initString.apply(this, arguments);\r\n\t\t// Unknown argument\r\n\t\telse\r\n\t\t\tthrow new A1Error(something).wasUnknown();\r\n\t}\r\n\r\n\t/***********\r\n\t *\tMETHODS\r\n\t ***********/\r\n\t/**\r\n\t *\t@return {string} in A1 notation\r\n\t */\r\n\tget(): string\r\n\t{\r\n\t\tlet start \t= ColA1(this._colStart)+RowA1(this._rowStart),\r\n\t\t\tend \t= ColA1(this._colEnd)+RowA1(this._rowEnd);\r\n\t\treturn start === end ? start : `${start}:${end}`;\r\n\t}\r\n\t/**\r\n\t *\t@return {string} in A1 notation\r\n\t */\r\n\ttoString(): string\r\n\t{\r\n\t\treturn this.get();\r\n\t}\r\n\t/**\r\n\t *\t@typedef {Object} Result\r\n\t *\t@property {number} colStart\r\n\t *\t@property {number} rowStart\r\n\t *\t@property {number} colEnd\r\n\t *\t@property {number} rowEnd\r\n\t *\t@property {string} a1\r\n\t *\t@property {number} rowsCount\r\n\t *\t@property {number} colsCount\r\n\t *\r\n\t *\t@return {Result} full information about range\r\n\t */\r\n\ttoJSON(): {\r\n\t\tcolStart: \tnumber,\r\n\t\trowStart: \tnumber,\r\n\t\tcolEnd: \tnumber,\r\n\t\trowEnd: \tnumber,\r\n\t\ta1: \t\tstring,\r\n\t\trowsCount: \tnumber,\r\n\t\tcolsCount: \tnumber,\r\n\t}\r\n\t{\r\n\t\treturn {\r\n\t\t\tcolStart: \tthis._colStart,\r\n\t\t\trowStart: \tthis._rowStart,\r\n\t\t\tcolEnd: \tthis._colEnd,\r\n\t\t\trowEnd: \tthis._rowEnd,\r\n\t\t\ta1: \t\tthis.get(),\r\n\t\t\trowsCount: \tthis._rowEnd - this._rowStart + 1,\r\n\t\t\tcolsCount: \tthis._colEnd - this._colStart + 1,\r\n\t\t}\r\n\t}\r\n\t/**\r\n\t *\t@return {number} start column\r\n\t */\r\n\tgetCol(): number\r\n\t{\r\n\t\treturn this._colStart;\r\n\t}\r\n\t/**\r\n\t *\t@return {number} end column\r\n\t */\r\n\tgetLastCol(): number\r\n\t{\r\n\t\treturn this._colEnd;\r\n\t}\r\n\t/**\r\n\t *\t@return {number} start row\r\n\t */\r\n\tgetRow(): number\r\n\t{\r\n\t\treturn this._rowStart;\r\n\t}\r\n\t/**\r\n\t *\t@return {number} end row\r\n\t */\r\n\tgetLastRow(): number\r\n\t{\r\n\t\treturn this._rowEnd;\r\n\t}\r\n\t/**\r\n\t *\t@return {number} columns count\r\n\t */\r\n\tgetWidth(): number\r\n\t{\r\n\t\treturn this._colEnd - this._colStart + 1;\r\n\t}\r\n\t/**\r\n\t *\t@return {number} rows count\r\n\t */\r\n\tgetHeight(): number\r\n\t{\r\n\t\treturn this._rowEnd - this._rowStart + 1;\r\n\t}\r\n\t/**\r\n\t *\t@return {A1} copy of this object\r\n\t */\r\n\tcopy(): A1\r\n\t{\r\n\t\treturn new A1(this.get());\r\n\t}\r\n\t/**\r\n\t *\tAdds N cells to range along the x-axis\r\n\t *\tif count >= 0 - adds to right\r\n\t *\tif count <  0 - adds to left\r\n\t *\t@param {number} count\r\n\t *\r\n\t *\t@return {this}\r\n\t */\r\n\taddX(count: number): this\r\n\t{\r\n\t\tif(!isValidNumber(count, false))\r\n\t\t\tthrow new A1Error(count).wasUnknown();\r\n\t\tcount >= 0\r\n\t\t\t? this._colEnd \t += count\r\n\t\t\t: this._colStart += count;\r\n\t\t(this._colStart <= 0) && (this._colStart = 1);\r\n\t\treturn this;\r\n\t}\r\n\t/**\r\n\t *\tAdds N cells to range along the y-axis\r\n\t *\tif count >= 0 - adds to bottom\r\n\t *\tif count <  0 - adds to top\r\n\t *\t@param {number} count\r\n\t *\r\n\t *\t@return {this}\r\n\t */\r\n\taddY(count: number): this\r\n\t{\r\n\t\tif(!isValidNumber(count, false))\r\n\t\t\tthrow new A1Error(count).wasUnknown();\r\n\t\tcount >= 0\r\n\t\t\t? this._rowEnd \t += count\r\n\t\t\t: this._rowStart += count;\r\n\t\t(this._rowStart <= 0) && (this._rowStart = 1);\r\n\t\treturn this;\r\n\t}\r\n\t/**\r\n\t *\tAdds N cells to range along the x/y-axis\r\n\t *\t@param {number} countX\r\n\t *\t@param {number} countY\r\n\t *\r\n\t *\t@return {this}\r\n\t */\r\n\tadd(countX: number, countY: number): this\r\n\t{\r\n\t\tthis.addX(countX);\r\n\t\tthis.addY(countY);\r\n\t\treturn this;\r\n\t}\r\n\t/**\r\n\t *\tRemoves N cells from range along the x-axis\r\n\t *\tif count >= 0 - removes from right\r\n\t *\tif count <  0 - removes from left\r\n\t *\t@param {number} count\r\n\t *\r\n\t *\t@return {this}\r\n\t */\r\n\tremoveX(count: number): this\r\n\t{\r\n\t\tif(!isValidNumber(count, false))\r\n\t\t\tthrow new A1Error(count).wasUnknown();\r\n\t\tif(count >= 0)\r\n\t\t{\r\n\t\t\tthis._colEnd -= count;\r\n\t\t\t(this._colEnd < this._colStart) && (this._colEnd = this._colStart);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tthis._colStart -= count;\r\n\t\t\t(this._colStart > this._colEnd) && (this._colStart = this._colEnd);\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\t/**\r\n\t *\tRemoves N cells from range along the y-axis\r\n\t *\tif count >= 0 - removes from bottom\r\n\t *\tif count <  0 - removes from top\r\n\t *\t@param {number} count\r\n\t *\r\n\t *\t@return {this}\r\n\t */\r\n\tremoveY(count: number): this\r\n\t{\r\n\t\tif(!isValidNumber(count, false))\r\n\t\t\tthrow new A1Error(count).wasUnknown();\r\n\t\tif(count >= 0)\r\n\t\t{\r\n\t\t\tthis._rowEnd -= count;\r\n\t\t\t(this._rowEnd < this._rowStart) && (this._rowEnd = this._rowStart);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tthis._rowStart -= count;\r\n\t\t\t(this._rowStart > this._rowEnd) && (this._rowStart = this._rowEnd);\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\t/**\r\n\t *\tRemoves N cells from range along the x/y-axis\r\n\t *\t@param {number} countX\r\n\t *\t@param {number} countY\r\n\t *\r\n\t *\t@return {this}\r\n\t */\r\n\tremove(countX: number, countY: number): this\r\n\t{\r\n\t\tthis.removeX(countX);\r\n\t\tthis.removeY(countY);\r\n\t\treturn this;\r\n\t}\r\n\t/**\r\n\t *\tShifts the range along the x-axis\r\n\t *\tIf offset >= 0 - shifts to right\r\n\t *\tIf offset <  0 - shifts to left\r\n\t *\t@param {number} offset\r\n\t *\r\n\t *\t@return {this}\r\n\t */\r\n\tshiftX(offset: number): this\r\n\t{\r\n\t\tif(!isValidNumber(offset, false))\r\n\t\t\tthrow new A1Error(offset).wasUnknown();\r\n\t\tlet diff \t= this._colEnd - this._colStart,\r\n\t\t\tstart \t= this._colStart + offset,\r\n\t\t\tend \t= this._colEnd \t + offset;\r\n\t\tthis._colStart \t= start > 0 ? start : 1;\r\n\t\tthis._colEnd \t= start > 0 ? end \t: diff + 1;\r\n\t\treturn this;\r\n\t}\r\n\t/**\r\n\t *\tShifts the range along the y-axis\r\n\t *\tIf offset >= 0 - shifts to bottom\r\n\t *\tIf offset <  0 - shifts to top\r\n\t *\t@param {number} offset\r\n\t *\r\n\t *\t@return {this}\r\n\t */\r\n\tshiftY(offset: number): this\r\n\t{\r\n\t\tif(!isValidNumber(offset, false))\r\n\t\t\tthrow new A1Error(offset).wasUnknown();\r\n\t\tlet diff \t= this._rowEnd - this._rowStart,\r\n\t\t\tstart \t= this._rowStart + offset,\r\n\t\t\tend \t= this._rowEnd \t + offset;\r\n\t\tthis._rowStart \t= start > 0 ? start : 1;\r\n\t\tthis._rowEnd \t= start > 0 ? end \t: diff + 1;\r\n\t\treturn this;\r\n\t}\r\n\t/**\r\n\t *\tShifts the range along the x/y-axis\r\n\t *\t@param {number} offsetX\r\n\t *\t@param {number} offsetY\r\n\t *\r\n\t *\t@return {this}\r\n\t */\r\n\tshift(offsetX: number, offsetY: number): this\r\n\t{\r\n\t\tthis.shiftX(offsetX);\r\n\t\tthis.shiftY(offsetY);\r\n\t\treturn this;\r\n\t}\r\n}\r\n\r\nexport default A1;","/**\r\n *\t@fileOverview Converts column letter to number\r\n *\t@author AdamL\r\n *\t@see https://stackoverflow.com/questions/21229180/convert-column-index-into-corresponding-column-letter\r\n *\t@param {string} col\r\n *\r\n *\t@return {number}\r\n */\r\nexport default function(col: string): number\r\n{\r\n\tlet column = 0,\r\n\t\tlength = col.length;\r\n\tfor(let i = 0; i < length; i++)\r\n\t\tcolumn += (col.charCodeAt(i) - 64) * Math.pow(26, length - i - 1);\r\n\treturn column;\r\n}","/**\r\n *\t@fileOverview Converts column letter to number\r\n *\t@author Flambino\r\n *\t@see https://codereview.stackexchange.com/questions/90112/a1notation-conversion-to-row-column-index\r\n *\t@param {string} col\r\n *\r\n *\t@return {number}\r\n */\r\nexport default function(col: string): number\r\n{\r\n\tlet i,\r\n\t\tl,\r\n\t\tchr,\r\n\t\tsum \t= 0,\r\n\t\tA \t\t= 'A'.charCodeAt(0),\r\n\t\tradix \t= 'Z'.charCodeAt(0) - A + 1;\r\n\tfor(i = 0, l = col.length; i < l; i++)\r\n\t{\r\n\t\tchr = col.charCodeAt(i);\r\n\t\tsum = sum * radix + chr - A + 1;\r\n\t}\r\n\treturn sum;\r\n}"],"names":["row","parseInt","col","temp","letter","String","fromCharCode","toString","a1","test","n","strict","isNumber","Number","isInteger","A1Error","Error","[object Object]","something","str","JSON","stringify","super","this","name","message","A1","something2","nRows","nCols","arguments","length","wasUnknown","type","_initNumber","apply","_initString","converter","cs","rs","ce","re","toUpperCase","match","_reg","colStart","_A1Col","colEnd","rowStart","A1Row","rowEnd","column","i","charCodeAt","Math","pow","A1Col1","l","chr","sum","A","radix","A1Col2","isValidA1","wasString","_parse","isValidNumber","wasNumber","ColA1","RowA1","args","all","every","join","_colStart","_rowStart","_colEnd","_rowEnd","rangeStart","rangeEnd","range","_converter","start","end","get","rowsCount","colsCount","count","countX","countY","addX","addY","removeX","removeY","offset","diff","offsetX","offsetY","shiftX","shiftY"],"mappings":"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"}