{"version":3,"file":"index.next.min.js","sources":["../src/converters.ts","../src/helpers.ts","../src/A1Error.ts","../src/enums.ts","../src/index.ts"],"sourcesContent":["/**\r\n * @file Contains converters from string to number and vice versa\r\n */\r\n\r\n/**\r\n * Converts column letter to number\r\n * @author AdamL\r\n * @see https://stackoverflow.com/questions/21229180/convert-column-index-into-corresponding-column-letter\r\n * @param {string} col\r\n *\r\n * @returns {number}\r\n */\r\nexport const colStringToNumber1 = (col: string): number =>\r\n{\r\n  const length = col.length;\r\n  let column = 0;\r\n  for(let i = 0; i < length; i++)\r\n    column += (col.charCodeAt(i) - 64) * Math.pow(26, length - i - 1);\r\n  return column;\r\n}\r\n\r\n/**\r\n * Converts column letter to number\r\n * @author Flambino\r\n * @see https://codereview.stackexchange.com/questions/90112/a1notation-conversion-to-row-column-index\r\n * @param {string} col\r\n *\r\n * @returns {number}\r\n */\r\nexport const colStringToNumber2 = (col: string): number =>\r\n{\r\n  let i,\r\n      l,\r\n      chr,\r\n      sum   = 0,\r\n      A     = 'A'.charCodeAt(0),\r\n      radix = 'Z'.charCodeAt(0) - A + 1;\r\n  for(i = 0, l = col.length; i < l; i++)\r\n  {\r\n    chr = col.charCodeAt(i);\r\n    sum = sum * radix + chr - A + 1;\r\n  }\r\n  return sum;\r\n}\r\n\r\n/**\r\n * Converts column number to letter\r\n * @author AdamL\r\n * @see https://stackoverflow.com/questions/21229180/convert-column-index-into-corresponding-column-letter\r\n * @param {number} col\r\n *\r\n * @returns {string}\r\n */\r\nexport const colNumberToString = (col: number): string =>\r\n{\r\n  let letter = '',\r\n      temp;\r\n  while(col > 0)\r\n  {\r\n    temp   = (col - 1) % 26;\r\n    letter = String.fromCharCode(temp + 65) + letter;\r\n    col    = (col - temp - 1) / 26;\r\n  }\r\n  return letter;\r\n}\r\n\r\n/**\r\n * Converts row string to number\r\n * @param {string} row\r\n *\r\n * @returns {number}\r\n */\r\nexport const rowStringToNumber = (row: string): number => parseInt(row, 10);\r\n\r\n/**\r\n * Converts row number to string\r\n * @param {number} row\r\n *\r\n * @returns {string}\r\n */\r\nexport const rowNumberToString = (row: number): string => String(row);\r\n","/**\r\n * @file Contains secondary functions\r\n */\r\n\r\n/**\r\n * Returns the type of a value\r\n * @param {unknown} some\r\n *\r\n * @returns {string}\r\n */\r\nexport const type = (some: unknown): string => typeof some;\r\n\r\n/**\r\n * Checks if a value is a string\r\n * @param {unknown} some\r\n *\r\n * @returns {boolean}\r\n */\r\nexport const isString = (some: unknown): boolean => type(some) === 'string';\r\n\r\n/**\r\n * Checks if a value is a number\r\n * @param {unknown} some\r\n *\r\n * @returns {boolean}\r\n */\r\nexport const isNumber = (some: unknown): boolean => type(some) === 'number' && Number.isInteger(some);\r\n\r\n/**\r\n * Checks if a value is a positive number\r\n * @param {unknown} some\r\n *\r\n * @returns {boolean}\r\n */\r\nexport const isPositiveNumber = (some: unknown): boolean => isNumber(some) && some > 0;\r\n\r\n/**\r\n * Checks if a value is a stringified number > 0 like \"1\", \"2\", ...\r\n * @param {unknown} some\r\n *\r\n * @returns {boolean}\r\n */\r\nexport const isStringifiedNumber = (some: unknown): boolean => isString(some) && /^[0-9]+$/.test(some as string) && isPositiveNumber(+some);\r\n\r\n/**\r\n * Checks if a value is a letter between a-zA-Z\r\n * @param {unknown} some\r\n *\r\n * @returns {boolean}\r\n */\r\nexport const isLetter = (some: unknown): boolean => isString(some) && /^[a-z]+$/i.test(some as string);\r\n\r\n/**\r\n * Checks validation of A1 notation\r\n * @param {unknown} some\r\n *\r\n * @returns {boolean}\r\n */\r\nexport const isValidA1 = (some: unknown): boolean => isString(some) && /^[A-Z]+\\d+(:[A-Z]+\\d+)?$/i.test(some as string);\r\n","/**\r\n * @fileOverview A1 notation errors\r\n */\r\nexport default class A1Error<T> extends Error\r\n{\r\n\tconstructor(a1: string)\r\n\tconstructor(col: number)\r\n\tconstructor(row: number)\r\n\tconstructor(unknown?: T)\r\n\tconstructor(something?: string | number | T)\r\n\t{\r\n\t\tconst str = JSON.stringify(something);\r\n\t\tsuper(str);\r\n\t\tthis.name \t\t= 'A1Error';\r\n\t\tthis.message \t= str;\r\n\t}\r\n\r\n  /**\r\n   * Was string\r\n   */\r\n\ts(): A1Error<T>\r\n\t{\r\n\t\tthis.message = `Invalid A1 notation: ${this.message}`;\r\n\t\treturn this;\r\n\t}\r\n\r\n  /**\r\n   * Was number\r\n   */\r\n\tn(): A1Error<T>\r\n\t{\r\n\t\tthis.message = `Invalid A1 number(s): ${this.message}`;\r\n\t\treturn this;\r\n\t}\r\n\r\n  /**\r\n   * Was unknown\r\n   */\r\n\tu(): A1Error<T>\r\n\t{\r\n\t\tthis.message = `Invalid A1 argument(s): ${this.message}`;\r\n\t\treturn this;\r\n\t}\r\n}\r\n","/**\r\n * @file Contains enums\r\n */\r\n\r\nexport enum Axis\r\n{\r\n  X = 'col',\r\n  Y = 'row',\r\n}\r\n","/**\r\n * @file Math operations and converting in A1 notation\r\n * Supports A1 notation like \"A1\" and \"A1:B2\"\r\n * @author FLighter\r\n */\r\n\r\nimport {\r\n  colStringToNumber1,// converter 1\r\n  colStringToNumber2,// converter 2\r\n  colNumberToString,\r\n  rowStringToNumber,\r\n  rowNumberToString,\r\n} from './converters';\r\nimport {\r\n  type,\r\n  isString,\r\n  isNumber,\r\n  isPositiveNumber,\r\n  isStringifiedNumber,\r\n  isLetter,\r\n  isValidA1,\r\n} from './helpers';\r\nimport A1Error from './A1Error';\r\nimport options from './options';\r\nimport {Axis} from './enums';\r\n\r\nclass A1\r\n{\r\n  // Regular expression for parsing\r\n  private static _reg:RegExp = /^([A-Z]+)(\\d+)(?::([A-Z]+)(\\d+))?$/;\r\n\r\n  /**\r\n   *\tExample: A1:B2\r\n   */\r\n  private _colStart: number = 0;// A -> 1\r\n  private _rowStart: number = 0;// 1 -> 1\r\n  private _colEnd:   number = 0;// B -> 2\r\n  private _rowEnd:   number = 0;// 2 -> 2\r\n  private _converter: 1 | 2 = 1;// converter 1 | 2\r\n\r\n  /**\r\n   *\tParses A1 notation\r\n   *\t@param {string} a1\r\n   *\t@param {1 | 2}  converter\r\n   *\r\n   *\t@return {object} {cs: number, rs: number, ce: number, re: number}\r\n   */\r\n  private static _parse(a1: string, converter: 1 | 2): {cs: number, rs: number, ce: number, re: number}\r\n  {\r\n    let [\r\n        ,\r\n        cs,// col start // A\r\n        rs,// row start // 1\r\n        ce,// col end \t// B\r\n        re,// row end \t// 2\r\n      ] = a1.toUpperCase().match(this._reg);\r\n    ce = ce || cs;\r\n    re = re || rs;\r\n    const colStart = this._A1Col(cs, converter),\r\n          colEnd   = this._A1Col(ce, converter),\r\n          rowStart = rowStringToNumber(rs),\r\n          rowEnd   = rowStringToNumber(re);\r\n    // For non-standard A1\r\n    return {\r\n      cs: colEnd > colStart ? colStart : colEnd,\r\n      rs: rowEnd > rowStart ? rowStart : rowEnd,\r\n      ce: colEnd > colStart ? colEnd \t : colStart,\r\n      re: rowEnd > rowStart ? rowEnd \t : rowStart,\r\n    }\r\n  }\r\n\r\n  /**\r\n   *\tConverts column letter to number using converter 1 or 2\r\n   *\t@param {string} a1\r\n   *\t@param {1 | 2} converter\r\n   *\r\n   *\t@return {number}\r\n   */\r\n  private static _A1Col(a1: string, converter: 1 | 2): number\r\n  {\r\n    return converter === 1 ? colStringToNumber1(a1) : colStringToNumber2(a1);\r\n  }\r\n\r\n  /******************\r\n   * STATIC METHODS\r\n   ******************/\r\n\r\n  /**\r\n   *\tChecks A1 notation\r\n   *\t@param {string} a1\r\n   *\r\n   *\t@return {boolean}\r\n   */\r\n  static isValid(a1: string): boolean\r\n  {\r\n    return isValidA1(a1);\r\n  }\r\n\r\n  /**\r\n   *\tConverts the first column letter from A1 to number\r\n   *\t@param {string} a1\r\n   *\t@param {1 | 2} [converter = 1]\r\n   *\r\n   *\t@return {number}\r\n   */\r\n  static getCol(a1: string, converter: 1 | 2 = 1): number\r\n  {\r\n    if(!isValidA1(a1))\r\n      throw new A1Error(a1).s();\r\n    return this._parse(a1, converter).cs;\r\n  }\r\n\r\n  /**\r\n   *\tConverts the last column letter from A1 to number\r\n   *\t@param {string} a1\r\n   *\t@param {1 | 2} [converter = 1]\r\n   *\r\n   *\t@return {number}\r\n   */\r\n  static getLastCol(a1: string, converter: 1 | 2 = 1): number\r\n  {\r\n    if(!isValidA1(a1))\r\n      throw new A1Error(a1).s();\r\n    return this._parse(a1, converter).ce;\r\n  }\r\n\r\n  /**\r\n   *\tConverts number to column letter in A1\r\n   *\t@param {number} col\r\n   *\r\n   *\t@return {string}\r\n   */\r\n  static toCol(col: number): string\r\n  {\r\n    if(!isPositiveNumber(col))\r\n      throw new A1Error(col).n();\r\n    return colNumberToString(col);\r\n  }\r\n\r\n  /**\r\n   *\tConverts the first row string to number\r\n   *\t@param {string} a1\r\n   *\r\n   *\t@return {number}\r\n   */\r\n  static getRow(a1: string): number\r\n  {\r\n    if(!isValidA1(a1))\r\n      throw new A1Error(a1).s();\r\n    return this._parse(a1, 1).rs;\r\n  }\r\n\r\n  /**\r\n   *\tConverts the last row string to number\r\n   *\t@param {string} a1\r\n   *\r\n   *\t@return {number}\r\n   */\r\n  static getLastRow(a1: string): number\r\n  {\r\n    if(!isValidA1(a1))\r\n      throw new A1Error(a1).s();\r\n    return this._parse(a1, 1).re;\r\n  }\r\n\r\n  /**\r\n   *\tConverts number to row string in A1\r\n   *\t@param {number} row\r\n   *\r\n   *\t@return {string}\r\n   */\r\n  static toRow(row: number): string\r\n  {\r\n    if(!isPositiveNumber(row))\r\n      throw new A1Error(row).n();\r\n    return rowNumberToString(row);\r\n  }\r\n\r\n  /**\r\n   *\t@param {string} a1\r\n   *\t@param {1 | 2} [converter = 1]\r\n   *\r\n   *\t@return {number} columns count\r\n   */\r\n  static getWidth(a1: string, converter: 1 | 2 = 1): number\r\n  {\r\n    if(!isValidA1(a1))\r\n      throw new A1Error(a1).s();\r\n    let {ce, cs} = this._parse(a1, converter);\r\n    return ce - cs + 1;\r\n  }\r\n\r\n  /**\r\n   *\t@param {string} a1\r\n   *\r\n   *\t@return {number} rows count\r\n   */\r\n  static getHeight(a1: string): number\r\n  {\r\n    if(!isValidA1(a1))\r\n      throw new A1Error(a1).s();\r\n    let {re, rs} = this._parse(a1, 1);\r\n    return re - rs + 1;\r\n  }\r\n\r\n  /***************\r\n   * CONSTRUCTOR\r\n   ***************/\r\n\r\n  /**\r\n   *\tIt handles case:\r\n   *\tconstructor(object: options)\r\n   *\t@param {options} options\r\n   */\r\n  private _initObject(options: options): void\r\n  {\r\n    const {\r\n      a1Start,\r\n      a1End,\r\n      colStart,\r\n      colEnd,\r\n      rowStart,\r\n      rowEnd,\r\n      nCols,\r\n      nRows,\r\n      converter,\r\n    } = options;\r\n\r\n    // Set converter\r\n    this._converter = converter === 2 ? 2 : 1;\r\n\r\n    let cs: number,\r\n        ce: number,\r\n        rs: number,\r\n        re: number;\r\n\r\n    const getValue = (some: unknown, canBeLetter: boolean = true): number =>\r\n    {\r\n      if(isPositiveNumber(some) || isStringifiedNumber(some))\r\n        return +some;\r\n      if(canBeLetter && isLetter(some))\r\n        return A1._A1Col(some as string, this._converter);\r\n      return 0;\r\n    };\r\n\r\n    /**\r\n     * Define start range\r\n     */\r\n\r\n    // From a1Start\r\n    if(isValidA1(a1Start))\r\n    {\r\n      const a1StartParsed = A1._parse(a1Start, this._converter);\r\n      cs = a1StartParsed.cs;\r\n      rs = a1StartParsed.rs;\r\n      const equalCol = a1StartParsed.cs === a1StartParsed.ce,\r\n            equalRow = a1StartParsed.rs === a1StartParsed.re,\r\n            equal    = equalCol && equalRow;\r\n      if(!equal || (equal && a1Start.includes(':')))\r\n      {\r\n        ce = a1StartParsed.ce;\r\n        re = a1StartParsed.re;\r\n      }\r\n    }\r\n\r\n    // From colStart & rowStart\r\n    if(!cs && colStart)\r\n      cs = getValue(colStart);\r\n    if(!rs && rowStart)\r\n      rs = getValue(rowStart, false);\r\n\r\n    /**\r\n     * Define end range\r\n     */\r\n\r\n    // From a1End\r\n    if(!ce && !re && isValidA1(a1End))\r\n    {\r\n      const a1EndParsed = A1._parse(a1End, this._converter);\r\n      ce = a1EndParsed.ce;\r\n      re = a1EndParsed.re;\r\n    }\r\n\r\n    // From colEnd & rowEnd\r\n    if(!ce && colEnd)\r\n      ce = getValue(colEnd);\r\n    if(!re && rowEnd)\r\n      re = getValue(rowEnd, false);\r\n\r\n    // From nCols & nRows\r\n    if(!ce && cs && isPositiveNumber(nCols))\r\n      ce = cs + nCols - 1;\r\n    if(!re && rs && isPositiveNumber(nRows))\r\n      re = rs + nRows - 1;\r\n\r\n    /**\r\n     * If only start/end range was defined\r\n     */\r\n    (cs && !ce) && (ce = cs);\r\n    (!cs && ce) && (cs = ce);\r\n    (rs && !re) && (re = rs);\r\n    (!rs && re) && (rs = re);\r\n\r\n    /**\r\n     * Check results\r\n     */\r\n    if(!cs || !rs || !ce || !re)\r\n      throw new A1Error(options).u();\r\n\r\n    /**\r\n     * Set ranges\r\n     */\r\n    this._colStart = cs;\r\n    this._rowStart = rs;\r\n    this._colEnd   = ce;\r\n    this._rowEnd   = re;\r\n  }\r\n\r\n  /**\r\n   *\tIt handles cases:\r\n   *\tconstructor(col: number, row: number)\r\n   *\tconstructor(col: number, row: number, nRows: number)\r\n   *\tconstructor(col: number, row: number, nRows: number, nCols: number)\r\n   *\t@param {number[]} args\r\n   */\r\n  private _initNumber(...args: number[]): void\r\n  {\r\n    let [col, row, nRows, nCols] = args;\r\n    nRows = nRows || 1;\r\n    nCols = nCols || 1;\r\n    let all = [col, row, nRows, nCols];\r\n    if(!all.every(n => isPositiveNumber(n)))\r\n      throw new A1Error(all.join(', ')).n();\r\n    this._colStart \t= col;\t\t\t\t// the first col\r\n    this._rowStart \t= row;\t\t\t\t// the first row\r\n    this._colEnd \t= col + nCols - 1;\t// how many cols in total (cols length)\r\n    this._rowEnd \t= row + nRows - 1;\t// how many rows in total (rows length)\r\n  }\r\n\r\n  /**\r\n   *\tIt handles cases:\r\n   *\tconstructor(range: string)\r\n   *\tconstructor(rangeStart: string, rangeEnd: string)\r\n   *\t@param {string[]} args\r\n   */\r\n  private _initString(...args: string[]): void\r\n  {\r\n    const [rangeStart, rangeEnd] = args;\r\n    const range = rangeEnd\r\n      ? `${rangeStart}:${rangeEnd}`// rangeStart: string, rangeEnd: string\r\n      : rangeStart;                // range: string\r\n    if(!isValidA1(range))\r\n      throw new A1Error(range).s();\r\n    const {cs, rs, ce, re} = A1._parse(range, this._converter);\r\n    this._colStart = cs;\r\n    this._rowStart = rs;\r\n    this._colEnd   = ce;\r\n    this._rowEnd   = re;\r\n  }\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  constructor(object: options)\r\n  constructor(range: string)\r\n  constructor(rangeStart: string, rangeEnd: string)\r\n  constructor(col: number, row: number)\r\n  constructor(col: number, row: number, nRows: number)\r\n  constructor(col: number, row: number, nRows: number, nCols: number)\r\n  constructor(something: string | number | options, something2?: string | number, nRows?: number, nCols?: number)\r\n  {\r\n    // No arguments\r\n    if(!arguments.length)\r\n      throw new A1Error().u();\r\n    // Object\r\n    if(something && type(something) === 'object')\r\n      this._initObject(something as options);\r\n    // Number\r\n    else if(isNumber(something))\r\n      this._initNumber.apply(this, arguments);\r\n    // String\r\n    else if(isString(something))\r\n      this._initString.apply(this, arguments);\r\n    // Unknown argument\r\n    else\r\n      throw new A1Error(something).u();\r\n  }\r\n\r\n  /***********\r\n   * METHODS\r\n   ***********/\r\n\r\n  /**\r\n   *\t@return {string} in A1 notation\r\n   */\r\n  get(): string\r\n  {\r\n    const start = colNumberToString(this._colStart)+rowNumberToString(this._rowStart),\r\n          end   = colNumberToString(this._colEnd)+rowNumberToString(this._rowEnd);\r\n    return start === end ? start : `${start}:${end}`;\r\n  }\r\n\r\n  /**\r\n   *\t@return {string} in A1 notation\r\n   */\r\n  toString(): string\r\n  {\r\n    return this.get();\r\n  }\r\n\r\n  /**\r\n   *\t@typedef {Object} Result\r\n   *\t@property {number} colStart\r\n   *\t@property {number} rowStart\r\n   *\t@property {number} colEnd\r\n   *\t@property {number} rowEnd\r\n   *\t@property {string} a1\r\n   *\t@property {number} rowsCount\r\n   *\t@property {number} colsCount\r\n   *\r\n   *\t@return {Result} full information about the range\r\n   */\r\n  toJSON(): {\r\n    colStart:  number,\r\n    rowStart:  number,\r\n    colEnd:    number,\r\n    rowEnd:    number,\r\n    a1:        string,\r\n    rowsCount: number,\r\n    colsCount: number,\r\n  }\r\n  {\r\n    return {\r\n      colStart:  this._colStart,\r\n      rowStart:  this._rowStart,\r\n      colEnd:    this._colEnd,\r\n      rowEnd:    this._rowEnd,\r\n      a1:        this.get(),\r\n      rowsCount: this._rowEnd - this._rowStart + 1,\r\n      colsCount: this._colEnd - this._colStart + 1,\r\n    }\r\n  }\r\n\r\n  /**\r\n   *\t@return {number} start column\r\n   */\r\n  getCol(): number\r\n  {\r\n    return this._colStart;\r\n  }\r\n\r\n  /**\r\n   *\t@return {number} end column\r\n   */\r\n  getLastCol(): number\r\n  {\r\n    return this._colEnd;\r\n  }\r\n\r\n  /**\r\n   *\t@return {number} start row\r\n   */\r\n  getRow(): number\r\n  {\r\n    return this._rowStart;\r\n  }\r\n\r\n  /**\r\n   *\t@return {number} end row\r\n   */\r\n  getLastRow(): number\r\n  {\r\n    return this._rowEnd;\r\n  }\r\n\r\n  /**\r\n   *\t@return {number} columns count\r\n   */\r\n  getWidth(): number\r\n  {\r\n    return this._colEnd - this._colStart + 1;\r\n  }\r\n\r\n  /**\r\n   *\t@return {number} rows count\r\n   */\r\n  getHeight(): number\r\n  {\r\n    return this._rowEnd - this._rowStart + 1;\r\n  }\r\n\r\n  /**\r\n   *\t@return {A1} copy of this object\r\n   */\r\n  copy(): A1\r\n  {\r\n    return new A1(this.get());\r\n  }\r\n\r\n  /**\r\n   * Sets a value to the start column\r\n   * @param {string | number} val\r\n   *\r\n   * @returns {this}\r\n   */\r\n  setCol(val: string | number): this\r\n  {\r\n    return this._setFields(val, '_colStart', Axis.X);\r\n  }\r\n\r\n  /**\r\n   * Sets a value to the end column\r\n   * @param {string | number} val\r\n   *\r\n   * @returns {this}\r\n   */\r\n  setLastCol(val: string | number): this\r\n  {\r\n    return this._setFields(val, '_colEnd', Axis.X);\r\n  }\r\n\r\n  /**\r\n   * Sets a value to the start row\r\n   * @param {string | number} val\r\n   *\r\n   * @returns {this}\r\n   */\r\n  setRow(val: string | number): this\r\n  {\r\n    return this._setFields(val, '_rowStart', Axis.Y, false);\r\n  }\r\n\r\n  /**\r\n   * Sets a value to the end row\r\n   * @param {string | number} val\r\n   *\r\n   * @returns {this}\r\n   */\r\n  setLastRow(val: string | number): this\r\n  {\r\n    return this._setFields(val, '_rowEnd', Axis.Y, false);\r\n  }\r\n\r\n  /**\r\n   *\tAdds N cells to range along the x-axis\r\n   *\tif count >= 0 - adds to right\r\n   *\tif count <  0 - adds to left\r\n   *\t@param {number} count\r\n   *\r\n   *\t@return {this}\r\n   */\r\n  addX(count: number): this\r\n  {\r\n    return this._addFields(count, Axis.X);\r\n  }\r\n\r\n  /**\r\n   *\tAdds N cells to range along the y-axis\r\n   *\tif count >= 0 - adds to bottom\r\n   *\tif count <  0 - adds to top\r\n   *\t@param {number} count\r\n   *\r\n   *\t@return {this}\r\n   */\r\n  addY(count: number): this\r\n  {\r\n    return this._addFields(count, Axis.Y);\r\n  }\r\n\r\n  /**\r\n   *\tAdds N cells to range along the x/y-axis\r\n   *\t@param {number} countX\r\n   *\t@param {number} countY\r\n   *\r\n   *\t@return {this}\r\n   */\r\n  add(countX: number, countY: number): this\r\n  {\r\n    return this.addX(countX).addY(countY);\r\n  }\r\n\r\n  /**\r\n   *\tRemoves N cells from range along the x-axis\r\n   *\tif count >= 0 - removes from right\r\n   *\tif count <  0 - removes from left\r\n   *\t@param {number} count\r\n   *\r\n   *\t@return {this}\r\n   */\r\n  removeX(count: number): this\r\n  {\r\n    return this._removeFields(count, Axis.X);\r\n  }\r\n\r\n  /**\r\n   *\tRemoves N cells from range along the y-axis\r\n   *\tif count >= 0 - removes from bottom\r\n   *\tif count <  0 - removes from top\r\n   *\t@param {number} count\r\n   *\r\n   *\t@return {this}\r\n   */\r\n  removeY(count: number): this\r\n  {\r\n    return this._removeFields(count, Axis.Y);\r\n  }\r\n\r\n  /**\r\n   *\tRemoves N cells from range along the x/y-axis\r\n   *\t@param {number} countX\r\n   *\t@param {number} countY\r\n   *\r\n   *\t@return {this}\r\n   */\r\n  remove(countX: number, countY: number): this\r\n  {\r\n    return this.removeX(countX).removeY(countY);\r\n  }\r\n\r\n  /**\r\n   *\tShifts the range along the x-axis\r\n   *\tIf offset >= 0 - shifts to right\r\n   *\tIf offset <  0 - shifts to left\r\n   *\t@param {number} offset\r\n   *\r\n   *\t@return {this}\r\n   */\r\n  shiftX(offset: number): this\r\n  {\r\n    return this._shiftFields(offset, Axis.X);\r\n  }\r\n\r\n  /**\r\n   *\tShifts the range along the y-axis\r\n   *\tIf offset >= 0 - shifts to bottom\r\n   *\tIf offset <  0 - shifts to top\r\n   *\t@param {number} offset\r\n   *\r\n   *\t@return {this}\r\n   */\r\n  shiftY(offset: number): this\r\n  {\r\n    return this._shiftFields(offset, Axis.Y);\r\n  }\r\n\r\n  /**\r\n   *\tShifts the range along the x/y-axis\r\n   *\t@param {number} offsetX\r\n   *\t@param {number} offsetY\r\n   *\r\n   *\t@return {this}\r\n   */\r\n  shift(offsetX: number, offsetY: number): this\r\n  {\r\n    return this.shiftX(offsetX).shiftY(offsetY);\r\n  }\r\n\r\n  /**\r\n   * Sets a value to the specified field\r\n   * @param {string | number} val\r\n   * @param {string} field\r\n   * @param {Axis} axis\r\n   * @param {boolean} [canBeLetter = true]\r\n   *\r\n   * @returns {this}\r\n   */\r\n  private _setFields(\r\n    val: string | number,\r\n    field: string,\r\n    axis: Axis,\r\n    canBeLetter: boolean = true,\r\n  ): this\r\n  {\r\n    if(isPositiveNumber(val) || isStringifiedNumber(val))\r\n      this[field] = +val;\r\n    else if(canBeLetter && isLetter(val))\r\n      this[field] = A1._A1Col(val as string, this._converter);\r\n    else\r\n      throw new A1Error(val).u();\r\n\r\n    if(this[`_${axis}Start`] > this[`_${axis}End`])\r\n      throw new A1Error(`The first column or row can't be bigger than the last, got: ${val}`);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Adds N cells to the range along the x/y-axis\r\n   * @param {number} count\r\n   * @param {Axis} axis\r\n   *\r\n   * @returns {this}\r\n   */\r\n  private _addFields(count: number, axis: Axis): this\r\n  {\r\n    if(!isNumber(count))\r\n      throw new A1Error(count).u();\r\n    const fieldStart = `_${axis}Start`,\r\n          fieldEnd   = `_${axis}End`;\r\n    count >= 0\r\n      ? this[fieldEnd]   += count\r\n      : this[fieldStart] += count;\r\n    (this[fieldStart] <= 0) && (this[fieldStart] = 1);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Removes N cells from the range along the x/y-axis\r\n   * @param {number} count\r\n   * @param {Axis} axis\r\n   *\r\n   * @returns {this}\r\n   */\r\n  private _removeFields(count: number, axis: Axis): this\r\n  {\r\n    if(!isNumber(count))\r\n      throw new A1Error(count).u();\r\n    const fieldStart = `_${axis}Start`,\r\n          fieldEnd   = `_${axis}End`;\r\n    if(count >= 0)\r\n    {\r\n      this[fieldEnd] -= count;\r\n      (this[fieldEnd] < this[fieldStart]) && (this[fieldEnd] = this[fieldStart]);\r\n    }\r\n    else\r\n    {\r\n      this[fieldStart] -= count;\r\n      (this[fieldStart] > this[fieldEnd]) && (this[fieldStart] = this[fieldEnd]);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Shifts the specified fields along x/y-axis\r\n   * @param {number} offset\r\n   * @param {Axis} axis\r\n   *\r\n   * @returns {this}\r\n   */\r\n  private _shiftFields(offset: number, axis: Axis): this\r\n  {\r\n    if(!isNumber(offset))\r\n      throw new A1Error(offset).u();\r\n    const fieldStart = `_${axis}Start`,\r\n          fieldEnd   = `_${axis}End`;\r\n    const diff  = this[fieldEnd] - this[fieldStart],\r\n          start = this[fieldStart] + offset,\r\n          end   = this[fieldEnd]   + offset;\r\n    this[fieldStart] = start > 0 ? start : 1;\r\n    this[fieldEnd]   = start > 0 ? end   : diff + 1;\r\n    return this;\r\n  }\r\n}\r\n\r\nexport default A1;\r\n"],"names":["colNumberToString","col","temp","letter","String","fromCharCode","rowStringToNumber","row","parseInt","rowNumberToString","type","some","isString","isNumber","Number","isInteger","isPositiveNumber","isStringifiedNumber","test","isLetter","isValidA1","A1Error","Error","[object Object]","something","str","JSON","stringify","super","this","name","message","Axis","A1","something2","nRows","nCols","arguments","length","u","_initObject","_initNumber","apply","_initString","a1","converter","cs","rs","ce","re","toUpperCase","match","_reg","colStart","_A1Col","colEnd","rowStart","rowEnd","column","i","charCodeAt","Math","pow","colStringToNumber1","l","chr","sum","A","radix","colStringToNumber2","s","_parse","n","options","a1Start","a1End","_converter","getValue","canBeLetter","a1StartParsed","equalCol","equalRow","equal","includes","a1EndParsed","_colStart","_rowStart","_colEnd","_rowEnd","args","all","every","join","rangeStart","rangeEnd","range","start","end","get","rowsCount","colsCount","val","_setFields","X","Y","count","_addFields","countX","countY","addX","addY","_removeFields","removeX","removeY","offset","_shiftFields","offsetX","offsetY","shiftX","shiftY","field","axis","fieldStart","fieldEnd","diff"],"mappings":"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"}