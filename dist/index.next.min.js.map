{"version":3,"file":"index.next.min.js","sources":["../src/converters.ts","../src/helpers.ts","../src/A1Error.ts","../src/index.ts"],"sourcesContent":["/**\n * @file Contains converters from string to number and vice versa\n */\n\n/**\n * Converts column letter to number\n * @author AdamL\n * @see https://stackoverflow.com/questions/21229180/convert-column-index-into-corresponding-column-letter\n * @param {string} col\n *\n * @returns {number}\n */\nexport const colStringToNumber1 = (col: string): number =>\n{\n  const length = col.length;\n  let column = 0;\n  for(let i = 0; i < length; i++)\n    column += (col.charCodeAt(i) - 64) * Math.pow(26, length - i - 1);\n  return column;\n}\n\n/**\n * Converts column letter to number\n * @author Flambino\n * @see https://codereview.stackexchange.com/questions/90112/a1notation-conversion-to-row-column-index\n * @param {string} col\n *\n * @returns {number}\n */\nexport const colStringToNumber2 = (col: string): number =>\n{\n  let i,\n      l,\n      chr,\n      sum   = 0,\n      A     = 'A'.charCodeAt(0),\n      radix = 'Z'.charCodeAt(0) - A + 1;\n  for(i = 0, l = col.length; i < l; i++)\n  {\n    chr = col.charCodeAt(i);\n    sum = sum * radix + chr - A + 1;\n  }\n  return sum;\n}\n\n/**\n * Converts column number to letter\n * @author AdamL\n * @see https://stackoverflow.com/questions/21229180/convert-column-index-into-corresponding-column-letter\n * @param {number} col\n *\n * @returns {string}\n */\nexport const colNumberToString = (col: number): string =>\n{\n  let letter = '',\n      temp;\n  while(col > 0)\n  {\n    temp   = (col - 1) % 26;\n    letter = String.fromCharCode(temp + 65) + letter;\n    col    = (col - temp - 1) / 26;\n  }\n  return letter;\n}\n\n/**\n * Converts row string to number\n * @param {string} row\n *\n * @returns {number}\n */\nexport const rowStringToNumber = (row: string): number => parseInt(row, 10);\n\n/**\n * Converts row number to string\n * @param {number} row\n *\n * @returns {string}\n */\nexport const rowNumberToString = (row: number): string => String(row);\n","/**\n * @file Contains secondary functions\n */\n\n/**\n * Returns the type of a value\n * @param {unknown} some\n *\n * @returns {string}\n */\nexport const type = (some: unknown): string => typeof some;\n\n/**\n * Checks if a value is a string\n * @param {unknown} some\n *\n * @returns {boolean}\n */\nexport const isString = (some: unknown): boolean => type(some) === 'string';\n\n/**\n * Checks if a value is a number\n * @param {unknown} some\n *\n * @returns {boolean}\n */\nexport const isNumber = (some: unknown): boolean => type(some) === 'number' && Number.isInteger(some);\n\n/**\n * Checks if a value is a positive number\n * @param {unknown} some\n *\n * @returns {boolean}\n */\nexport const isPositiveNumber = (some: unknown): boolean => isNumber(some) && some > 0;\n\n/**\n * Checks if a value is a stringified number > 0 like \"1\", \"2\", ...\n * @param {unknown} some\n *\n * @returns {boolean}\n */\nexport const isStringifiedNumber = (some: unknown): boolean => isString(some) && /^[0-9]+$/.test(some as string) && isPositiveNumber(+some);\n\n/**\n * Checks if a value is a letter between a-zA-Z\n * @param {unknown} some\n *\n * @returns {boolean}\n */\nexport const isLetter = (some: unknown): boolean => isString(some) && /^[a-z]+$/i.test(some as string);\n\n/**\n * Checks validation of A1 notation\n * @param {unknown} some\n *\n * @returns {boolean}\n */\nexport const isValidA1 = (some: unknown): boolean => isString(some) && /^[A-Z]+\\d+(:[A-Z]+\\d+)?$/i.test(some as string);\n","/**\n * @fileOverview A1 notation errors\n */\nexport default class A1Error<T> extends Error\n{\n\tconstructor(a1: string)\n\tconstructor(col: number)\n\tconstructor(row: number)\n\tconstructor(unknown?: T)\n\tconstructor(something?: string | number | T)\n\t{\n\t\tconst str = JSON.stringify(something);\n\t\tsuper(str);\n\t\tthis.name \t\t= 'A1Error';\n\t\tthis.message \t= str;\n\t}\n\n  /**\n   * Was string\n   */\n\ts(): A1Error<T>\n\t{\n\t\tthis.message = `Invalid A1 notation: ${this.message}`;\n\t\treturn this;\n\t}\n\n  /**\n   * Was number\n   */\n\tn(): A1Error<T>\n\t{\n\t\tthis.message = `Invalid A1 number(s): ${this.message}`;\n\t\treturn this;\n\t}\n\n  /**\n   * Was unknown\n   */\n\tu(): A1Error<T>\n\t{\n\t\tthis.message = `Invalid A1 argument(s): ${this.message}`;\n\t\treturn this;\n\t}\n}\n","/**\n * @file Math operations and converting in A1 notation\n * Supports A1 notation like \"A1\" and \"A1:B2\"\n * @author FLighter\n */\n\nimport {\n  colStringToNumber1,// converter 1\n  colStringToNumber2,// converter 2\n  colNumberToString,\n  rowStringToNumber,\n  rowNumberToString,\n} from './converters';\nimport {\n  type,\n  isString,\n  isNumber,\n  isPositiveNumber,\n  isStringifiedNumber,\n  isLetter,\n  isValidA1,\n} from './helpers';\nimport A1Error from './A1Error';\nimport options from './options';\n// import {Axis} from './enums';\n\nenum Axis\n{\n  X = 'col',\n  Y = 'row',\n}\n\nclass A1\n{\n  // Regular expression for parsing\n  private static _reg:RegExp = /^([A-Z]+)(\\d+)(?::([A-Z]+)(\\d+))?$/;\n\n  /**\n   *\tExample: A1:B2\n   */\n  private _colStart: number = 0;// A -> 1\n  private _rowStart: number = 0;// 1 -> 1\n  private _colEnd:   number = 0;// B -> 2\n  private _rowEnd:   number = 0;// 2 -> 2\n  private _converter: 1 | 2 = 1;// converter 1 | 2\n\n  /**\n   *\tParses A1 notation\n   *\t@param {string} a1\n   *\t@param {1 | 2}  converter\n   *\n   *\t@return {object} {cs: number, rs: number, ce: number, re: number}\n   */\n  private static _parse(a1: string, converter: 1 | 2): {cs: number, rs: number, ce: number, re: number}\n  {\n    let [\n        ,\n        cs,// col start // A\n        rs,// row start // 1\n        ce,// col end \t// B\n        re,// row end \t// 2\n      ] = a1.toUpperCase().match(this._reg);\n    ce = ce || cs;\n    re = re || rs;\n    const colStart = this._A1Col(cs, converter),\n          colEnd   = this._A1Col(ce, converter),\n          rowStart = rowStringToNumber(rs),\n          rowEnd   = rowStringToNumber(re);\n    // For non-standard A1\n    return {\n      cs: colEnd > colStart ? colStart : colEnd,\n      rs: rowEnd > rowStart ? rowStart : rowEnd,\n      ce: colEnd > colStart ? colEnd \t : colStart,\n      re: rowEnd > rowStart ? rowEnd \t : rowStart,\n    }\n  }\n\n  /**\n   *\tConverts column letter to number using converter 1 or 2\n   *\t@param {string} a1\n   *\t@param {1 | 2} converter\n   *\n   *\t@return {number}\n   */\n  private static _A1Col(a1: string, converter: 1 | 2): number\n  {\n    return converter === 1 ? colStringToNumber1(a1) : colStringToNumber2(a1);\n  }\n\n  /******************\n   * STATIC METHODS\n   ******************/\n\n  /**\n   *\tChecks A1 notation\n   *\t@param {string} a1\n   *\n   *\t@return {boolean}\n   */\n  static isValid(a1: string): boolean\n  {\n    return isValidA1(a1);\n  }\n\n  /**\n   *\tConverts the first column letter from A1 to number\n   *\t@param {string} a1\n   *\t@param {1 | 2} [converter = 1]\n   *\n   *\t@return {number}\n   */\n  static getCol(a1: string, converter: 1 | 2 = 1): number\n  {\n    if(!isValidA1(a1))\n      throw new A1Error(a1).s();\n    return this._parse(a1, converter).cs;\n  }\n\n  /**\n   *\tConverts the last column letter from A1 to number\n   *\t@param {string} a1\n   *\t@param {1 | 2} [converter = 1]\n   *\n   *\t@return {number}\n   */\n  static getLastCol(a1: string, converter: 1 | 2 = 1): number\n  {\n    if(!isValidA1(a1))\n      throw new A1Error(a1).s();\n    return this._parse(a1, converter).ce;\n  }\n\n  /**\n   *\tConverts number to column letter in A1\n   *\t@param {number} col\n   *\n   *\t@return {string}\n   */\n  static toCol(col: number): string\n  {\n    if(!isPositiveNumber(col))\n      throw new A1Error(col).n();\n    return colNumberToString(col);\n  }\n\n  /**\n   *\tConverts the first row string to number\n   *\t@param {string} a1\n   *\n   *\t@return {number}\n   */\n  static getRow(a1: string): number\n  {\n    if(!isValidA1(a1))\n      throw new A1Error(a1).s();\n    return this._parse(a1, 1).rs;\n  }\n\n  /**\n   *\tConverts the last row string to number\n   *\t@param {string} a1\n   *\n   *\t@return {number}\n   */\n  static getLastRow(a1: string): number\n  {\n    if(!isValidA1(a1))\n      throw new A1Error(a1).s();\n    return this._parse(a1, 1).re;\n  }\n\n  /**\n   *\tConverts number to row string in A1\n   *\t@param {number} row\n   *\n   *\t@return {string}\n   */\n  static toRow(row: number): string\n  {\n    if(!isPositiveNumber(row))\n      throw new A1Error(row).n();\n    return rowNumberToString(row);\n  }\n\n  /**\n   *\t@param {string} a1\n   *\t@param {1 | 2} [converter = 1]\n   *\n   *\t@return {number} columns count\n   */\n  static getWidth(a1: string, converter: 1 | 2 = 1): number\n  {\n    if(!isValidA1(a1))\n      throw new A1Error(a1).s();\n    let {ce, cs} = this._parse(a1, converter);\n    return ce - cs + 1;\n  }\n\n  /**\n   *\t@param {string} a1\n   *\n   *\t@return {number} rows count\n   */\n  static getHeight(a1: string): number\n  {\n    if(!isValidA1(a1))\n      throw new A1Error(a1).s();\n    let {re, rs} = this._parse(a1, 1);\n    return re - rs + 1;\n  }\n\n  /***************\n   * CONSTRUCTOR\n   ***************/\n\n  /**\n   *\tIt handles case:\n   *\tconstructor(object: options)\n   *\t@param {options} options\n   */\n  private _initObject(options: options): void\n  {\n    const {\n      a1Start,\n      a1End,\n      colStart,\n      colEnd,\n      rowStart,\n      rowEnd,\n      nCols,\n      nRows,\n      converter,\n    } = options;\n\n    // Set converter\n    this._converter = converter === 2 ? 2 : 1;\n\n    let cs: number,\n        ce: number,\n        rs: number,\n        re: number;\n\n    const getValue = (some: unknown, canBeLetter: boolean = true): number =>\n    {\n      if(isPositiveNumber(some) || isStringifiedNumber(some))\n        return +some;\n      if(canBeLetter && isLetter(some))\n        return A1._A1Col(some as string, this._converter);\n      return 0;\n    };\n\n    /**\n     * Define start range\n     */\n\n    // From a1Start\n    if(isValidA1(a1Start))\n    {\n      const a1StartParsed = A1._parse(a1Start, this._converter);\n      cs = a1StartParsed.cs;\n      rs = a1StartParsed.rs;\n      const equalCol = a1StartParsed.cs === a1StartParsed.ce,\n            equalRow = a1StartParsed.rs === a1StartParsed.re,\n            equal    = equalCol && equalRow;\n      if(!equal || (equal && a1Start.includes(':')))\n      {\n        ce = a1StartParsed.ce;\n        re = a1StartParsed.re;\n      }\n    }\n\n    // From colStart & rowStart\n    if(!cs && colStart)\n      cs = getValue(colStart);\n    if(!rs && rowStart)\n      rs = getValue(rowStart, false);\n\n    /**\n     * Define end range\n     */\n\n    // From a1End\n    if(!ce && !re && isValidA1(a1End))\n    {\n      const a1EndParsed = A1._parse(a1End, this._converter);\n      ce = a1EndParsed.ce;\n      re = a1EndParsed.re;\n    }\n\n    // From colEnd & rowEnd\n    if(!ce && colEnd)\n      ce = getValue(colEnd);\n    if(!re && rowEnd)\n      re = getValue(rowEnd, false);\n\n    // From nCols & nRows\n    if(!ce && cs && isPositiveNumber(nCols))\n      ce = cs + nCols - 1;\n    if(!re && rs && isPositiveNumber(nRows))\n      re = rs + nRows - 1;\n\n    /**\n     * If only start/end range was defined\n     */\n    (cs && !ce) && (ce = cs);\n    (!cs && ce) && (cs = ce);\n    (rs && !re) && (re = rs);\n    (!rs && re) && (rs = re);\n\n    /**\n     * Check results\n     */\n    if(!cs || !rs || !ce || !re)\n      throw new A1Error(options).u();\n\n    /**\n     * Set ranges\n     */\n    this._colStart = cs;\n    this._rowStart = rs;\n    this._colEnd   = ce;\n    this._rowEnd   = re;\n  }\n\n  /**\n   *\tIt handles cases:\n   *\tconstructor(col: number, row: number)\n   *\tconstructor(col: number, row: number, nRows: number)\n   *\tconstructor(col: number, row: number, nRows: number, nCols: number)\n   *\t@param {number[]} args\n   */\n  private _initNumber(...args: number[]): void\n  {\n    let [col, row, nRows, nCols] = args;\n    nRows = nRows || 1;\n    nCols = nCols || 1;\n    let all = [col, row, nRows, nCols];\n    if(!all.every(n => isPositiveNumber(n)))\n      throw new A1Error(all.join(', ')).n();\n    this._colStart \t= col;\t\t\t\t// the first col\n    this._rowStart \t= row;\t\t\t\t// the first row\n    this._colEnd \t= col + nCols - 1;\t// how many cols in total (cols length)\n    this._rowEnd \t= row + nRows - 1;\t// how many rows in total (rows length)\n  }\n\n  /**\n   *\tIt handles cases:\n   *\tconstructor(range: string)\n   *\tconstructor(rangeStart: string, rangeEnd: string)\n   *\t@param {string[]} args\n   */\n  private _initString(...args: string[]): void\n  {\n    const [rangeStart, rangeEnd] = args;\n    const range = rangeEnd\n      ? `${rangeStart}:${rangeEnd}`// rangeStart: string, rangeEnd: string\n      : rangeStart;                // range: string\n    if(!isValidA1(range))\n      throw new A1Error(range).s();\n    const {cs, rs, ce, re} = A1._parse(range, this._converter);\n    this._colStart = cs;\n    this._rowStart = rs;\n    this._colEnd   = ce;\n    this._rowEnd   = re;\n  }\n\n  /**\n   * Constructor\n   */\n  constructor(object: options)\n  constructor(range: string)\n  constructor(rangeStart: string, rangeEnd: string)\n  constructor(col: number, row: number)\n  constructor(col: number, row: number, nRows: number)\n  constructor(col: number, row: number, nRows: number, nCols: number)\n  constructor(something: string | number | options, something2?: string | number, nRows?: number, nCols?: number)\n  {\n    // No arguments\n    if(!arguments.length)\n      throw new A1Error().u();\n    // Object\n    if(something && type(something) === 'object')\n      this._initObject(something as options);\n    // Number\n    else if(isNumber(something))\n      this._initNumber.apply(this, arguments);\n    // String\n    else if(isString(something))\n      this._initString.apply(this, arguments);\n    // Unknown argument\n    else\n      throw new A1Error(something).u();\n  }\n\n  /***********\n   * METHODS\n   ***********/\n\n  /**\n   *\t@return {string} in A1 notation\n   */\n  get(): string\n  {\n    const start = colNumberToString(this._colStart)+rowNumberToString(this._rowStart),\n          end   = colNumberToString(this._colEnd)+rowNumberToString(this._rowEnd);\n    return start === end ? start : `${start}:${end}`;\n  }\n\n  /**\n   *\t@return {string} in A1 notation\n   */\n  toString(): string\n  {\n    return this.get();\n  }\n\n  /**\n   *\t@typedef {Object} Result\n   *\t@property {number} colStart\n   *\t@property {number} rowStart\n   *\t@property {number} colEnd\n   *\t@property {number} rowEnd\n   *\t@property {string} a1\n   *\t@property {number} rowsCount\n   *\t@property {number} colsCount\n   *\n   *\t@return {Result} full information about the range\n   */\n  toJSON(): {\n    colStart:  number,\n    rowStart:  number,\n    colEnd:    number,\n    rowEnd:    number,\n    a1:        string,\n    rowsCount: number,\n    colsCount: number,\n  }\n  {\n    return {\n      colStart:  this._colStart,\n      rowStart:  this._rowStart,\n      colEnd:    this._colEnd,\n      rowEnd:    this._rowEnd,\n      a1:        this.get(),\n      rowsCount: this._rowEnd - this._rowStart + 1,\n      colsCount: this._colEnd - this._colStart + 1,\n    }\n  }\n\n  /**\n   *\t@return {number} start column\n   */\n  getCol(): number\n  {\n    return this._colStart;\n  }\n\n  /**\n   *\t@return {number} end column\n   */\n  getLastCol(): number\n  {\n    return this._colEnd;\n  }\n\n  /**\n   *\t@return {number} start row\n   */\n  getRow(): number\n  {\n    return this._rowStart;\n  }\n\n  /**\n   *\t@return {number} end row\n   */\n  getLastRow(): number\n  {\n    return this._rowEnd;\n  }\n\n  /**\n   *\t@return {number} columns count\n   */\n  getWidth(): number\n  {\n    return this._colEnd - this._colStart + 1;\n  }\n\n  /**\n   *\t@return {number} rows count\n   */\n  getHeight(): number\n  {\n    return this._rowEnd - this._rowStart + 1;\n  }\n\n  /**\n   *\t@return {A1} copy of this object\n   */\n  copy(): A1\n  {\n    return new A1(this.get());\n  }\n\n  /**\n   * Sets a value to the start column\n   * @param {string | number} val\n   *\n   * @returns {this}\n   */\n  setCol(val: string | number): this\n  {\n    return this._setFields(val, '_colStart', Axis.X);\n  }\n\n  /**\n   * Sets a value to the end column\n   * @param {string | number} val\n   *\n   * @returns {this}\n   */\n  setLastCol(val: string | number): this\n  {\n    return this._setFields(val, '_colEnd', Axis.X);\n  }\n\n  /**\n   * Sets a value to the start row\n   * @param {string | number} val\n   *\n   * @returns {this}\n   */\n  setRow(val: string | number): this\n  {\n    return this._setFields(val, '_rowStart', Axis.Y, false);\n  }\n\n  /**\n   * Sets a value to the end row\n   * @param {string | number} val\n   *\n   * @returns {this}\n   */\n  setLastRow(val: string | number): this\n  {\n    return this._setFields(val, '_rowEnd', Axis.Y, false);\n  }\n\n  /**\n   *\tAdds N cells to range along the x-axis\n   *\tif count >= 0 - adds to right\n   *\tif count <  0 - adds to left\n   *\t@param {number} count\n   *\n   *\t@return {this}\n   */\n  addX(count: number): this\n  {\n    return this._addFields(count, Axis.X);\n  }\n\n  /**\n   *\tAdds N cells to range along the y-axis\n   *\tif count >= 0 - adds to bottom\n   *\tif count <  0 - adds to top\n   *\t@param {number} count\n   *\n   *\t@return {this}\n   */\n  addY(count: number): this\n  {\n    return this._addFields(count, Axis.Y);\n  }\n\n  /**\n   *\tAdds N cells to range along the x/y-axis\n   *\t@param {number} countX\n   *\t@param {number} countY\n   *\n   *\t@return {this}\n   */\n  add(countX: number, countY: number): this\n  {\n    return this.addX(countX).addY(countY);\n  }\n\n  /**\n   *\tRemoves N cells from range along the x-axis\n   *\tif count >= 0 - removes from right\n   *\tif count <  0 - removes from left\n   *\t@param {number} count\n   *\n   *\t@return {this}\n   */\n  removeX(count: number): this\n  {\n    return this._removeFields(count, Axis.X);\n  }\n\n  /**\n   *\tRemoves N cells from range along the y-axis\n   *\tif count >= 0 - removes from bottom\n   *\tif count <  0 - removes from top\n   *\t@param {number} count\n   *\n   *\t@return {this}\n   */\n  removeY(count: number): this\n  {\n    return this._removeFields(count, Axis.Y);\n  }\n\n  /**\n   *\tRemoves N cells from range along the x/y-axis\n   *\t@param {number} countX\n   *\t@param {number} countY\n   *\n   *\t@return {this}\n   */\n  remove(countX: number, countY: number): this\n  {\n    return this.removeX(countX).removeY(countY);\n  }\n\n  /**\n   *\tShifts the range along the x-axis\n   *\tIf offset >= 0 - shifts to right\n   *\tIf offset <  0 - shifts to left\n   *\t@param {number} offset\n   *\n   *\t@return {this}\n   */\n  shiftX(offset: number): this\n  {\n    return this._shiftFields(offset, Axis.X);\n  }\n\n  /**\n   *\tShifts the range along the y-axis\n   *\tIf offset >= 0 - shifts to bottom\n   *\tIf offset <  0 - shifts to top\n   *\t@param {number} offset\n   *\n   *\t@return {this}\n   */\n  shiftY(offset: number): this\n  {\n    return this._shiftFields(offset, Axis.Y);\n  }\n\n  /**\n   *\tShifts the range along the x/y-axis\n   *\t@param {number} offsetX\n   *\t@param {number} offsetY\n   *\n   *\t@return {this}\n   */\n  shift(offsetX: number, offsetY: number): this\n  {\n    return this.shiftX(offsetX).shiftY(offsetY);\n  }\n\n  /**\n   * Sets a value to the specified field\n   * @param {string | number} val\n   * @param {string} field\n   * @param {Axis} axis\n   * @param {boolean} [canBeLetter = true]\n   *\n   * @returns {this}\n   */\n  private _setFields(\n    val: string | number,\n    field: string,\n    axis: Axis,\n    canBeLetter: boolean = true,\n  ): this\n  {\n    if(isPositiveNumber(val) || isStringifiedNumber(val))\n      this[field] = +val;\n    else if(canBeLetter && isLetter(val))\n      this[field] = A1._A1Col(val as string, this._converter);\n    else\n      throw new A1Error(val).u();\n\n    if(this[`_${axis}Start`] > this[`_${axis}End`])\n      throw new A1Error(`The first column or row can't be bigger than the last, got: ${val}`);\n\n    return this;\n  }\n\n  /**\n   * Adds N cells to the range along the x/y-axis\n   * @param {number} count\n   * @param {Axis} axis\n   *\n   * @returns {this}\n   */\n  private _addFields(count: number, axis: Axis): this\n  {\n    if(!isNumber(count))\n      throw new A1Error(count).u();\n    const fieldStart = `_${axis}Start`,\n          fieldEnd   = `_${axis}End`;\n    count >= 0\n      ? this[fieldEnd]   += count\n      : this[fieldStart] += count;\n    (this[fieldStart] <= 0) && (this[fieldStart] = 1);\n    return this;\n  }\n\n  /**\n   * Removes N cells from the range along the x/y-axis\n   * @param {number} count\n   * @param {Axis} axis\n   *\n   * @returns {this}\n   */\n  private _removeFields(count: number, axis: Axis): this\n  {\n    if(!isNumber(count))\n      throw new A1Error(count).u();\n    const fieldStart = `_${axis}Start`,\n          fieldEnd   = `_${axis}End`;\n    if(count >= 0)\n    {\n      this[fieldEnd] -= count;\n      (this[fieldEnd] < this[fieldStart]) && (this[fieldEnd] = this[fieldStart]);\n    }\n    else\n    {\n      this[fieldStart] -= count;\n      (this[fieldStart] > this[fieldEnd]) && (this[fieldStart] = this[fieldEnd]);\n    }\n    return this;\n  }\n\n  /**\n   * Shifts the specified fields along x/y-axis\n   * @param {number} offset\n   * @param {Axis} axis\n   *\n   * @returns {this}\n   */\n  private _shiftFields(offset: number, axis: Axis): this\n  {\n    if(!isNumber(offset))\n      throw new A1Error(offset).u();\n    const fieldStart = `_${axis}Start`,\n          fieldEnd   = `_${axis}End`;\n    const diff  = this[fieldEnd] - this[fieldStart],\n          start = this[fieldStart] + offset,\n          end   = this[fieldEnd]   + offset;\n    this[fieldStart] = start > 0 ? start : 1;\n    this[fieldEnd]   = start > 0 ? end   : diff + 1;\n    return this;\n  }\n}\n\nexport default A1;\n"],"names":["colNumberToString","col","temp","letter","String","fromCharCode","rowStringToNumber","row","parseInt","rowNumberToString","type","some","isString","isNumber","Number","isInteger","isPositiveNumber","isStringifiedNumber","test","isLetter","isValidA1","A1Error","Error","[object Object]","something","str","JSON","stringify","super","this","name","message","Axis","A1","something2","nRows","nCols","arguments","length","u","_initObject","_initNumber","apply","_initString","a1","converter","cs","rs","ce","re","toUpperCase","match","_reg","colStart","_A1Col","colEnd","rowStart","rowEnd","column","i","charCodeAt","Math","pow","colStringToNumber1","l","chr","sum","A","radix","colStringToNumber2","s","_parse","n","options","a1Start","a1End","_converter","getValue","canBeLetter","a1StartParsed","equalCol","equalRow","equal","includes","a1EndParsed","_colStart","_rowStart","_colEnd","_rowEnd","args","all","every","join","rangeStart","rangeEnd","range","start","end","get","rowsCount","colsCount","val","_setFields","X","Y","count","_addFields","countX","countY","addX","addY","_removeFields","removeX","removeY","offset","_shiftFields","offsetX","offsetY","shiftX","shiftY","field","axis","fieldStart","fieldEnd","diff"],"mappings":"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"}